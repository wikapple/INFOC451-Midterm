const pool = require('../config/database');
const debug = require('debug')('app:mediaDataAccess');
const chalk = require('chalk');


class MediaDataAccess {

    async getAllCategories() {
        try {
            const sqlQuery = `CALL category_SelectAll()`;
            const queryResult = await pool.query(sqlQuery, []);
            return queryResult[0];

        } catch (error) {
            debug(error);
        }
    }

    async getAllMediaTypes() {
        try {
            const sqlQuery = `CALL mediaType_SelectAll()`;
            const queryResult = await pool.query(sqlQuery, []);
            return queryResult[0];

        } catch (error) {
            debug(error);
        }
    }

    async getMediaListByType(typeId) {
        try {
            const sqlQuery = `CALL media_SelectByType(?)`;
            const queryResult = await pool.query(sqlQuery, [typeId]);
            let mediaList = queryResult[0];

            for(let media of mediaList){
                const categoryQuery = `Call category_SelectByMediaId(?)`;
                const categoriesQueryResult = await pool.query(categoryQuery, [media.id])
                media.categories = categoriesQueryResult[0];
            }
            return mediaList;
        } catch (error) {
            debug(error);
        }
    }
    async getMediaListByTypeAndFilter(typeId, filterValue) {
        try {
            const sqlQuery = `CALL media_Filter(?,?)`;
            const queryResult = await pool.query(sqlQuery, [typeId, filterValue]);
            let mediaList = queryResult[0];

            for(let media of mediaList){
                const categoryQuery = `Call category_SelectByMediaId(?)`;
                const categoriesQueryResult = await pool.query(categoryQuery, [media.id])
                media.categories = categoriesQueryResult[0];
            }
            return mediaList;
        } catch (error) {
            debug(error);
        }
    }

    async createMedia(createRequest) {
        try {
            const { uniqueIdentifier, name, description, publisher, isChildSafe, type, size, author, } = createRequest;

            const categoryList = createRequest['categories[]'].join();
            const isChildSafeEnabled = isChildSafe === 'on';
            const sqlQuery = `CALL media_Insert(?, ?, ?, ?, ?, ?, ?, ?, ?)`;

            await pool.query(
                sqlQuery,
                [uniqueIdentifier, name, description, publisher, isChildSafeEnabled, type, size, categoryList, author],
                (error, results, fields) => {
                    if (error) {
                        throw error;
                    }
                }
            );
            return true;

        } catch (error) {
            debug(error);
            return false;
        }
    }
    async updateMedia(updateRequest) {
        try {
            const { id, uniqueIdentifier, name, description, publisher, isChildSafe, type, size, categories, author, } = updateRequest;

            const sqlQuery = `CALL media_UpdateById(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

            await pool.query(
                sqlQuery,
                [id, uniqueIdentifier, name, description, publisher, isChildSafe, type, categories, author, size],
                (error, results, fields) => {
                    if (error) {
                        throw error;
                    }
                }
            );
            return true;

        } catch (error) {
            debug(error);
            return false;
        }
    }
    async deleteMediaById(mediaIdToDelete) {
        try {
            const sqlQuery = `Call media_DeleteById(?)`;

            await pool.query(
                sqlQuery,
                [mediaIdToDelete],
                (error, results, fields) => {
                if (error) {
                    throw error;
                }
            }
            );
            return true;

        } catch (error) {
            debug(error);
            return false;
        }
    }
}

module.exports = MediaDataAccess;
